import { createClientFromRequest } from 'npm:@base44/sdk@0.7.1';

Deno.serve(async (req) => {
    try {
        const base44 = createClientFromRequest(req);
        
        let body;
        try {
            const text = await req.text();
            body = JSON.parse(text);
        } catch (parseError) {
            return Response.json({ 
                error: 'Invalid JSON',
                details: parseError.message 
            }, { status: 400 });
        }
        
        const providedSecret = body.secret;
        const expectedSecret = Deno.env.get('ZAPIER_SHIFTS_WEBHOOK_SECRET');
        
        if (!expectedSecret) {
            return Response.json({ 
                error: 'ZAPIER_SHIFTS_WEBHOOK_SECRET not configured'
            }, { status: 500 });
        }
        
        if (!providedSecret || providedSecret !== expectedSecret) {
            return Response.json({ 
                error: 'Invalid secret'
            }, { status: 401 });
        }
        
        if (!body.employee_name || !body.department_name || !body.start || !body.end) {
            return Response.json({ 
                error: 'Missing required fields',
                required: ['employee_name', 'department_name', 'start', 'end']
            }, { status: 400 });
        }

        const stores = await base44.asServiceRole.entities.Store.filter({
            name: body.department_name
        });

        if (!stores || stores.length === 0) {
            return Response.json({ 
                error: `Store not found: ${body.department_name}`
            }, { status: 404 });
        }

        const parseDateTime = (dateStr) => {
            if (!dateStr) return null;
            
            const parts = dateStr.trim().split(' ');
            if (parts.length === 2) {
                const dateParts = parts[0].split('/');
                if (dateParts.length === 3) {
                    const day = dateParts[0].padStart(2, '0');
                    const month = dateParts[1].padStart(2, '0');
                    const year = dateParts[2];
                    const time = parts[1];
                    return `${year}-${month}-${day}T${time}:00`;
                }
            }
            return null;
        };

        const scheduledStart = parseDateTime(body.start);
        const scheduledEnd = parseDateTime(body.end);
        const actualStart = body.timeclock_start ? parseDateTime(body.timeclock_start) : null;
        const actualEnd = body.timeclock_end ? parseDateTime(body.timeclock_end) : null;

        // ✅ CHECK FOR DUPLICATES BEFORE CREATING
        // A shift is duplicate if it has same:
        // - employee_name, store_id, shift_date, scheduled_start, scheduled_end
        const shiftDate = scheduledStart ? scheduledStart.split('T')[0] : new Date().toISOString().split('T')[0];
        
        const existingShifts = await base44.asServiceRole.entities.Shift.filter({
            employee_name: body.employee_name,
            store_id: stores[0].id,
            shift_date: shiftDate,
            scheduled_start: scheduledStart,
            scheduled_end: scheduledEnd
        });

        if (existingShifts && existingShifts.length > 0) {
            return Response.json({
                success: false,
                message: 'Duplicate shift detected - not created',
                existing_shift_id: existingShifts[0].id,
                shift_info: {
                    employee_name: body.employee_name,
                    store_name: body.department_name,
                    shift_date: shiftDate,
                    scheduled_start: scheduledStart,
                    scheduled_end: scheduledEnd
                }
            }, { status: 409 }); // 409 Conflict
        }

        // Calculate ritardo and minuti_di_ritardo
        let ritardo = false;
        let minuti_di_ritardo = 0;

        if (actualStart && scheduledStart) {
            try {
                const actualStartDate = new Date(actualStart);
                const scheduledStartDate = new Date(scheduledStart);
                
                // Check if dates are valid
                if (!isNaN(actualStartDate.getTime()) && !isNaN(scheduledStartDate.getTime())) {
                    const differenzaMs = actualStartDate.getTime() - scheduledStartDate.getTime();
                    const minutiEffettivi = Math.round(differenzaMs / (1000 * 60));
                    
                    // Se c'è ritardo (anche di 1 solo minuto)
                    if (minutiEffettivi > 0) {
                        ritardo = true;
                        // Arrotonda a scaglioni di 15 minuti in eccesso
                        minuti_di_ritardo = Math.ceil(minutiEffettivi / 15) * 15;
                    }
                }
            } catch (e) {
                console.error('Error calculating delay:', e);
            }
        }

        const shiftData = {
            employee_name: body.employee_name,
            employee_id_external: body.employee_id || null,
            store_name: body.department_name,
            store_id: stores[0].id,
            shift_date: shiftDate,
            scheduled_start: scheduledStart,
            scheduled_end: scheduledEnd,
            scheduled_minutes: parseInt(body.minutes) || 0,
            actual_start: actualStart,
            actual_end: actualEnd,
            actual_minutes: body.timeclock_minutes ? parseInt(body.timeclock_minutes) : null,
            shift_type: body.timesheet_type_name || '',
            employee_group_name: body.employee_group_name || null,
            ritardo: ritardo,
            minuti_di_ritardo: minuti_di_ritardo
        };

        const shift = await base44.asServiceRole.entities.Shift.create(shiftData);

        return Response.json({
            success: true,
            shift: {
                id: shift.id,
                employee_name: shift.employee_name,
                store_name: shift.store_name,
                scheduled_start: shift.scheduled_start,
                actual_start: shift.actual_start,
                ritardo: shift.ritardo,
                minuti_di_ritardo: shift.minuti_di_ritardo
            }
        }, { status: 201 });

    } catch (error) {
        return Response.json({ 
            error: error.message
        }, { status: 500 });
    }
});